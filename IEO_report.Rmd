```{r setup, cache = TRUE, echo = FALSE, results = 'asis'}
library("knitr")
dumpcssfile <- function(fname) {
  paste(c('<style type = "text/css">', readLines(fname), '</style>\n'),
        collapse = "\n")
}

opts_chunk$set(cache = TRUE,
               autodep = TRUE,
               fig.align = "center",
               comment = "",
               tidy = TRUE,
               message = FALSE,
               source = function(x, options) {
    paste("\\begin{lstlisting}[numbers=left, firstnumber=last]\n", x, 
        "\\end{lstlisting}\n", sep = "")
}) 
# Some modifications from http://stackoverflow.com/a/27633734/2886003

knit_hooks$set(error = function(x, options) stop(x),
               fig.cap = function(before, options, envir) {
                 if (!before) {
                   paste0('<p class = "caption">', options$fig.cap, "</p>")
                 }
               })

# Modifications based on https://rpubs.com/ajlyons/autonumfigs
# A function for generating captions and cross-references
fig <- local({
    i <- 0
    list(
        cap=function(refName, text, center=FALSE, col="black", inline=FALSE) {
            i <<- i + 1
            ref[[refName]] <<- i
            css_ctr <- ""
            if (center) css_ctr <- "text-align:center; display:inline-block; width:100%;"
            cap_txt <- paste0("<span style=\"color:", col, "; ", css_ctr, "\">Figure ", i, ": ", text , "</span>")
            anchor <- paste0("<a name=\"", refName, "\"></a>")
            if (inline) {
                paste0(anchor, cap_txt)    
            } else {
                list(anchor=anchor, cap_txt=cap_txt)
            }
        },
        
        ref=function(refName, link=FALSE, checkRef=TRUE) {
            
            ## This function puts in a cross reference to a caption. You refer to the
            ## caption with the refName that was passed to fig$cap() (not the code chunk name).
            ## The cross reference can be hyperlinked.
            
            if (checkRef && !refName %in% names(ref)) stop(paste0("fig$ref() error: ", refName, " not found"))
            if (link) {
                paste0("<A HREF=\"#", refName, "\">Figure ", ref[[refName]], "</A>")
            } else {
                paste0("Figure ", ref[[refName]])
            }
        },
        
        ref_all=function(){
            ## For debugging
            ref
        })
})

## This chunk replaces the default hook for processing plots. It achieves the purposes,
## of laying out auto-numbered captions, but other functionality may be gone.
knit_hooks$set(plot = function(x, options) {
    sty <- ""
    if (options$fig.align == 'default') {
        sty <- ""
    } else {
        sty <- paste0(" style=\"text-align:", options$fig.align, ";\"")
    }
    
    if (is.list(options$fig.cap)) {
        ## options$fig.cap is a list returned by the function fig$cap()
        str_caption <- options$fig.cap$cap_txt
        str_anchr <- options$fig.cap$anchor
    } else {
        ## options$fig.cap is a character object (hard coded, no anchor)
        str_caption <- options$fig.cap
        str_anchr <- ""
    }
    
    paste('<figure', sty, '>', str_anchr, '<img src="',
        opts_knit$get('base.url'), paste(x, collapse = '.'),
        '"><figcaption>', str_caption, '</figcaption></figure>',
        sep = '')
    
})

## This chunck will read through *this* Rmd file, and attempt to extract all of the 
## labels (not caption text) used for Figure captions. These labels are used
## as anchors, so scanning through the document now will allow us to create cross references
## before the caption actually appears. 

## Get the name of this Rmd file
rmdFn <- knitr::current_input()  # filename of input document

## Read lines and close connection
rmdCon <- file(rmdFn, open = "r")
rmdLines <- readLines(rmdCon)
close(rmdCon)

## Pull out all occurences of at least one back tick, followed 
## by any number of characters, followed by fig$cap (all on one line)
figscap_idx <- grep("`+(.*)fig\\$cap", rmdLines)
rmdLines <- rmdLines[figscap_idx]

## Get rid of everything up until the start of the caption label
## This presumes the caption label is the first argument of fig$cap()
## E.g., fig.cap = fig$cap("my_label", ...)
rmdLinesSansPre <- sub("(.*)fig\\$cap(.*?)[\"']", "", rmdLines)

## Identify everything up until the first quote
match_data <- regexpr("(.*?)[\"']", rmdLinesSansPre)

## Reduce the length by one, because we're not interested in the final quote
attr(match_data, "match.length") <- attr(match_data, "match.length") - 1

## Extract
fig_labels <- regmatches(rmdLinesSansPre, match_data, invert=FALSE)

if (length(fig_labels) > 0) {

    ## Test for duplicates
    if (anyDuplicated(fig_labels) > 0) stop("Duplicate caption labels detected")
    
    ## Create a named list of Figure numbers
    ref <- as.list(1:length(fig_labels))
    names(ref) <- fig_labels
}    

cat(dumpcssfile(file.path("css", "ieo.css")))
```
---
output: html_document
---
# Analysis of a TCGA RNA-seq data set on Thyroid carcinoma (THCA)

#### Mauro Álvarez (mail)
#### Lluís Revilla(lluis.revilla01@estudiant.upf.edu)
#### Marina Reixachs (marina.reixachs01@estudiant.upf.edu)
#### Inés Sentís (mail) 

## Introduction

Thyroid cancer can develop from the different cells that form the follicles of the thyroid. This gland located at the base of the throat secretes hormones such as T3 and T4 that have their metabolic functionalities such as control of heart rate, blood pressure, body temperature and weight. [see it on cancergenome](http://cancergenome.nih.gov/cancersselected/thyroid). 

From the four types of thyroid cancer (papillary, follicular, medullary, and anaplastic thyroid cancer) Papillary Thyroid Carcinoma (PTC) is the most common type of thyroid cancer (Agrawal et al., 2014). It is more prevalent in women than men and its common diagnosis occurs around 49 years [old](http://cancergenome.nih.gov/cancersselected/thyroid).

Driver onco-mutations for this type of cancer appear as alterations of the MAPK signaling pathway and the PI3K-AKT pathway (Agrawal et al., 2014). Both are implied in cell proliferation and survival and in human tumorigenesis. The overactivation of the MAPK pathway because of mutations such as the BRAFV600E mutation, leads to the development of papillary thyroid cancer (PTC) from follicular thyroid cells (Xing, 2013). On the other hand, mutations that activate the PI3K-AKT pathway, such as mutations in RAS, PTEN and PIK3CA, mostly leads to development of follicular thyroid adenoma (FTA) and follicular thyroid cancer (FTC) also in follicular thyroid cells (Xing, 2013).

Research from The Cancer Genome Atlas focused on PTC and they found that a part from alterations in BRAF (specifically BRAFV600E) and RAS, there are other driver mutations such the ones in EIF1AX PPM1D, and CHEK2 genes that are main alterations for that type of thyroid cancer(Agrawal et al., 2014).

## Data import

We start importing the raw table of counts.

```{r start, message=FALSE}
library(SummarizedExperiment)

thca <- readRDS("seTHCA.rds") 
thca
```

Explore the column (phenotypic) data, which in this case corresponds to clinical
variables, and their corresponding metadata.

```{r explore1}
dim(colData(thca))
col.data <- colData(thca)
col.data[1:5, 1:5]

col.data.meta <- mcols(colData(thca), use.names=TRUE)
col.data.meta
```

Now, explore the row (feature) data.

```{r explore2}
row.ranges <- rowRanges(thca)
row.ranges
```

Looking deeper into col.data with:

```{r explore.col.data}
col.data[1:5, 30:35]
```

We can observe there are different ways to indicate that the data is not available (NA, [Not Available]...). Consequently, we decide to study which variables have more information. To do so, we create two functions, one (`na.replace`) to change those values into the standarized `NA` nomenclature, and `filter.info` to quantify how many of each variable is not `NA`.

```{r functions}

na.replace <- function(x){
    # Remove the unwanted factors
    lev <- levels(x)
    lev <- lev[!(lev %in% "[Not Available]")]
    lev <- lev[!(lev %in% "[Unknown]")]
    lev <- lev[!(lev %in% "[Not Applicable]")]
    lev <- lev[!(lev %in% "[Not Available]|[Not Available]|[Not Available]")]
    lev <- lev[!(lev %in% "[Not Evaluated]")]
    lev <- lev[!(lev %in% "None")]

    x <- factor(x, levels=lev)
}

filter.info <- function(x){
    # Function to filter the NA, [Not Available], [Not Applicable] and [Unknown]
    # Return the proportion of information on x
    nas <- sum(is.na(x))
    return(1 - (nas/length(x)))
}
```

We apply these functions to the `col.data` and we visualize it:

```{r col.data.analysis}
meta.info <- as.data.frame(lapply(col.data, na.replace))
variable.info <- sapply(meta.info, filter.info)

# Representing the information by column vs total information
relative.info <- variable.info[order(variable.info)]/sum(variable.info)
plot(relative.info, main="Information brought by column")

# Plotting the histogram of the information
hist(variable.info, 
     main = "Variables completness", xlab = "% of not NA of each variable", ylab = "Counts")
# Seeing the most informative to set a threshold,
# frequency are the number of columns with such % of information
hist(variable.info, xlim = c(0.3, 1), ylim = c(0, 35), 
     main = "Variables completness", xlab = "% of not NA of each variable", ylab = "Counts")
```

As we can see, in many variables the main value is just `NA` or other derivatives meaning "No information available for this variable". Therefore, in order to keep the most informative variables, we apply a threshold of 60% (of the values containing informative data) to select the relevant ones:

```{r select.filtered}
filtered <- meta.info[, variable.info  > 0.6]

dim(filtered)
meta.info.summary2 <- col.data.meta[variable.info  > 0.6,]
```

To explore the data we first create an object with `ggplot`:
```{r ggplot.config}
library("ggplot2")
fplot <- ggplot(as.data.frame(filtered))

## ggplot options for axes and background color
# Options of the labels
l <- theme(axis.text.x=element_text(angle = -90, hjust = 0, vjust = 1))
# Removing the background
b <-  theme(axis.line = element_line(colour = "black"),
            panel.grid.major.x = element_blank(),
            panel.grid.major.y = element_line(colour = "grey", size = 0.5, linetype = 2),
            panel.grid.minor.y = element_line(colour = "grey", size = 0.25, linetype = 3),
            panel.border = element_blank(),
            panel.background = element_blank())
y.axis = ylab("number of cases")
```

And we plot some relationships for some significant variables:
In the "normal" type samples most of the information is not available. This could be due to the fact that all "normal" samples were obtained from patients with tumors. So in order to have the maximum information of each sample, we infer "normal" samples information from its paired sample data (mainly gender and ethnicity).

```{r plots, fig.cap = fig$cap("Figure S1","Exploring the col.data")}
fplot + geom_bar(aes(type, fill = gender)) + b + y.axis + 
    ggtitle("Gender distribution across normal and tumour samples")
fplot + geom_bar(aes(type, fill = tumor_status)) + b + y.axis + 
    ggtitle("Tumor status across normal and tumour samples")
fplot + facet_wrap(~ gender) + geom_bar(aes(type, fill = ethnicity)) + b + 
    y.axis + ggtitle("... normal and tumour samples")
fplot + facet_wrap(~ ethnicity) + geom_bar(aes(race, fill = gender)) + b + l + 
    y.axis + scale_x_discrete(breaks=waiver(), 
labels=c("AM. INDIAN OR ALASKA NAT.", "ASIAN", "BLACK OR AFRICAN AM.", "WHITE", "NA")) +
    ggtitle("Ethnicity and origin ...")
fplot + geom_bar(aes(x=gender, fill = race)) + b + y.axis + ggtitle("some title")
fplot + facet_wrap(~type)+geom_bar(aes(tumor_focality, fill = gender)) + b + l + y.axis + xlab("tumor focality")
hd.xaxis <-  scale_x_discrete(name = "histologic diagnosis", breaks=waiver(), 
                            labels=c("Other specify", "Papillary - Classical", "Papillary - Follicular", "Papillary - Tall Cell", "NA"))
fplot + geom_bar(aes(histologic_diagnosis, fill = gender)) + b + l + hd.xaxis + y.axis +
    ggtitle("Gender distribution across different types of hystologic diagnosis")
ggplot(na.omit(as.data.frame(filtered))) + geom_bar(aes(age_at_diagnosis, na.rm = T, fill = histologic_diagnosis)) + b + l +  labs(x="age at diagnosis", y = y.axis)+ scale_fill_discrete(name = "histologic diagnosis", breaks=waiver(), 
 labels = c("Other specify", "Papillary - Classical", "Papillary - Follicular", "Papillary - Tall Cell", "NA")) + 
    ggtitle("Histologic diagnosis distribution across different ages")
```

We can see in `r fig$ref("Figure S1")` that the data has some patterns: there are more females than males and much more tumoral than normal samples.

As it could be seen in the previous plots, the most abundant population in the samples is the "white" and "not hispanic or latino", so we decide to perform the analysis on this group of individuals, whose tumoral sample correspond to the most common cancer in thyroids: Papillary Thyroid Carcinoma(PTC). With this approach we want to avoid to include in the analysis, samples that introduce variability (mainly differential expression due to enviromental or epigenetic factors) as much as possible. To have more insight on the disease we want to have just paired samples, that is, samples from the same participant. So we filter the data accordingly:

```{r subset}
# Paired data
paired <- intersect(thca[, thca$type == 'tumor']$bcr_patient_barcode, thca[, thca$type =='normal']$bcr_patient_barcode)
paired_mask <- thca$bcr_patient_barcode %in% paired

filtered_filt <- filtered[paired_mask, ]

# Imposing the selected conditions
tumor_names <- row.names(subset(filtered_filt, type == "tumor" &
                                    race == "WHITE" &
    histologic_diagnosis == "Thyroid Papillary Carcinoma - Classical/usual" &
        ethnicity == "NOT HISPANIC OR LATINO" ))

# Extracting the participants identifiers
participants <- unlist(lapply(tumor_names, substr, 9, 12))
participants <- participants[participants != ""]

check <- function(x, checklist){
    # Returning name of the sample just if the name is the same as in checklist
    a <- substr(x, 9, 12)
    if(a %in% checklist){
        return(x)
    }
}

# Extracting sample names of tumor and normal data.
sample_names <- unlist(lapply(row.names(filtered_filt), check, checklist = participants))
thca.filtered <- thca[, sample_names]

##NOT OK BUT IT's sth to start
thca.filtered$race <- replace(thca.filtered$race,which(is.na(thca.filtered$race)), "WHITE")

```

We explore again the variables for this subset:
```{r subset.explore}
meta.filtered.subset <- filtered_filt[row.names(filtered_filt) %in% sample_names, ]
mplot <- ggplot(meta.filtered.subset)
mplot + geom_bar(aes(type, fill = gender)) + b + y.axis
mplot + geom_bar(aes(type, fill = tumor_status)) + b + y.axis + scale_fill_discrete(name="tumor status")
mplot + facet_wrap(~ gender) + geom_bar(aes(type, fill = ethnicity)) + b + y.axis
mplot + facet_wrap(~ ethnicity) + geom_bar(aes(race, fill = gender)) + b + l + y.axis
mplot + geom_bar(aes(x=gender, fill = ethnicity)) + b + l  + y.axis
mplot + facet_wrap(~type)+geom_bar(aes(tumor_focality, fill = gender)) + b + l + y.axis
mplot + geom_bar(aes(histologic_diagnosis, fill = gender)) + b + l + y.axis + scale_x_discrete(name= "histogic diagnosis", breaks=waiver(), labels = c("Papillary - Classical", "NA")) + ggtitle("Gender distribution across different types of hystologic diagnosis")
ggplot(na.omit(meta.filtered.subset)) + geom_bar(aes(age_at_diagnosis, fill = histologic_diagnosis)) + b + l + y.axis + xlab("age at diagnosis") + scale_fill_discrete(name = "histologic diagnosis", breaks=waiver(), labels = c("Papillary - Classical", "NA")) + ggtitle("Histologic diagnosis distribution across different ages")
```


To perform quality assessment and normalization we need first to load the
[edgeR](http://bioconductor.org/packages/edgeR) R/Bioconductor package and
create a `DGEList' object.

```{r edgeR, message = FALSE}
library(edgeR)

# Normalization just with the selected samples
dge.subset <- DGEList(counts=assays(thca.filtered)$counts, genes=mcols(thca.filtered))
dge <- DGEList(counts=assays(thca)$counts, genes=mcols(thca))
```

Now calculate $\log_2$ CPM values of expression and put them as an additional
assay element to ease their manipulation.

```{r logCPM}
assays(thca.filtered)$logCPM <- cpm(dge.subset, log=TRUE, prior.count=3)
assays(thca.filtered)$logCPM[1:5, 1:5]
logCPM <- assays(thca.filtered)$logCPM
```

## Quality assessment and normalization

### Library sizes

Let's examine the library sizes in terms of total number of sequence read counts
per sample. Figure S1 below shows library sizes per sample in increasing order.

<!---
you can control the height and width in pixels of the figure with 'out.height' and 'out.width'
--->

```{r libsizes, echo=FALSE, out.width="600px", fig.cap="Figure S1: Library sizes in increasing order."}
ord <- order(dge$sample$lib.size/1e6)
barplot(dge$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads",
        xlab="Samples", col=c("blue", "red")[(thca$type[ord] == "tumor") + 1])
legend("topleft", c("tumor", "normal"), fill=c("red", "blue"), inset=0.01)

ord.subset <- order(dge.subset$sample$lib.size/1e6)
barplot(dge.subset$sample$lib.size[ord.subset]/1e6, las=1, ylab="Millions of reads",
        xlab="Samples", col=c("blue", "red")[(thca.filtered$type[ord.subset] == "tumor") + 1])
legend("topleft", c("tumor", "normal"), fill=c("red", "blue"), inset=0.01)
```

This figure reveals substantial differences in sequencing depth between samples
and we may consider discarding those samples whose depth is substantially lower
than the rest. To identify who are these samples we may simply look at the
actual numbers including portion of the sample identifier that distinguishes them.

```{r libsize}
sampledepth <- round(dge.subset$sample$lib.size / 1e6, digits = 1)
names(sampledepth) <- substr(sample_names, 6, 12)

qqnorm(sampledepth)
qqline(sampledepth)
```

Looking into the qqplot we decide to filter out those below 40 or above 70 but keeping only those that are paired:

```{r refiltering.names}
sample_names <- sample_names[sampledepth > 40 & sampledepth < 70]

keep.paired <- function(pattern, x){
    # Return the names if it is paired
    pos <- grep(pattern, x, fixed = TRUE)
    if (length(pos) > 1){
        return(x[pos])
    }
}

sample_names <- unique(unlist(lapply(substr(sample_names, 9, 12), keep.paired, sample_names)))

thca.filtered <- thca.filtered[, colnames(thca.filtered) %in% sample_names]
dge.subset <- DGEList(counts=assays(thca.filtered)$counts, genes=mcols(thca.filtered))
```

### Distribution of expression levels among samples

Let's look at the distribution of expression values per sample in terms of
logarithmic CPM units. Due to the large number of samples, we display tumor
and normal samples separately, and are shown in Figure S2.

<!---
the option echo = FALSE hides the R code. When plotting in general one does not
want to see the code. Options fig.height and fig.width control height and width
of the plot in inches while out.height and out.width do it in the final output
file; see http://yihui.name/knitr/options for full details.
--->

```{r distRawExp, fig.height = 4, fig.width = 10, out.width = "800px", fig.cap = "Figure S2: Non-parametric density distribution of expression profiles per sample."}
library(geneplotter)
par(mfrow = c(1, 2))
multidensity(as.list(as.data.frame(assays(thca.filtered[, thca.filtered$type ==  "tumor"])$logCPM)),
             xlab = "log 2 CPM", legend = NULL, main = "Tumor samples", las = 1)
multidensity(as.list(as.data.frame(assays(thca.filtered[, thca.filtered$type ==  "normal"])$logCPM)),
             xlab = "log 2 CPM", legend = NULL, main = "Normal samples", las = 1)
```

Seeing this plots we suspect the two spikes are due to the effect of the read length and GC content of each transcript. Therefore we will correct them with the package cqn:

```{r cqn, message=FALSE}
library("cqn")
cqn.subset <- cqn(assays(thca.filtered)$counts, lengths = rowRanges(thca.filtered)$txlen,
                  x = rowRanges(thca.filtered)$txgc,
                  sizeFactors = colSums(assays(thca.filtered)$counts))
par(mfrow=c(1,2))
cqnplot(cqn.subset, n = 1, xlab = "GC content", lty = 1)
cqnplot(cqn.subset, n = 2, xlab = "length", lty = 1)
```

As we can see there is more variance on the extremes values of GC content and length, and more variability due to length than due to GC.

We can see if the distribution of expression values per sample in terms of logarithmic CPM units. Due to the large number of samples, we display tumor and normal samples separately:

```{r distExp, fig.height = 4, fig.width = 10, out.width = "800px", fig.cap = "Figure S2: Non-parametric density distribution of expression profiles per sample."}
cqn.logCPM <- cqn.subset$y + cqn.subset$offset
assays(thca.filtered)$cqn.logCPM <- cqn.logCPM
par(mfrow = c(1, 2))
multidensity(as.list(as.data.frame(cqn.logCPM[,thca.filtered$type ==  "tumor"])),
             xlab = "log 2 CPM", legend = NULL, main = "Tumor samples", las = 1)
multidensity(as.list(as.data.frame(cqn.logCPM[, thca.filtered$type ==  "normal"])),
             xlab = "log 2 CPM", legend = NULL, main = "Normal samples", las = 1)
```

We can clearly see that this are quite better than the previous ones used without GC and length normalization on the second spike. With this normalization we do not appreciate substantial differences between the samples in the distribution of expression values. However, below 0 there is a lot of variability.

### Distribution of expression levels among genes

Let's calculate now the average expression per gene through all the samples. Figure S3
shows the distribution of those values across genes.

```{r exprdist, out.width = "400px", fig.cap = "Figure S3: Distribution of average expression level per gene."}
par(mfrow = c(1, 2))
avgexp <- rowMeans(assays(thca.filtered)$logCPM)
hist(avgexp, xlab = "log2 CPM", main = "Using DGEList normalization", las = 1)
abline(v = 1, col = "red", lwd = 2)

# Using the corrected logCPM
avgexp.cqn <- rowMeans(assays(thca.filtered)$cqn.logCPM)
hist(avgexp.cqn, xlab = "log2 CPM", main = "Using cqn normalization", las = 1)
abline(v = 1, col = "red", lwd = 2)
```

### Filtering of lowly-expressed genes

In the light of this plot, we may consider a cutoff of 1 log CPM unit as minimum value
of expression to select genes being expressed across samples. Using this cutoff we proceed
to filter out lowly-expressed genes.

```{r filter.low.expr}
mask <- avgexp.cqn > 1
sum(mask)
# thca.filtered <- thca.filtered[mask, ]
dge.subset <- dge.subset[mask, ]
```

### Normalization

Since we will use the offsets computed by `cqn`, there is no need to normalize using the normalization tools from `edgeR`, such as `calcNormFactors` according to cqn vignette.

```{r norm}
dge.subset$offset <- cqn.subset$glm.offset
```

### MA-plots

We examine now the MA-plots of the normalized expression profiles. We look first to
the tumor samples.

<!---
Here we make a MA-plot for each sample. The options 'fig.height' and 'fig.width'
control the relative image size in *inches*. The final image size results from
'height'x'dpi' and 'width'x'dpi', where 'dpi' is the image resolution in
"dots per inch" (by default dpi = 72). To scale the image to a desired size use
'out.width' and 'out.height'. More information at http://yihui.name/knitr/options
--->

```{r maPlotsTumor, fig.height = 16, fig.width = 6, dpi = 100, fig.cap = "Figure S4: MA-plots of the tumor samples."}
par(mfrow = c(8, 3), mar = c(4, 3, 4, 1))
setmp <- thca.filtered[, thca.filtered$type ==  "tumor"]
dgetmp <- dge.subset[, thca.filtered$type ==  "tumor"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main = samplename, las = 1)
  abline(h = 0, col = "blue", lwd = 2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col = "red", lwd = 2)
}
```

We do not observe samples with major expression-level dependent biases. Let's look now to the normal samples.

```{r maPlotsNormal, fig.height = 16, fig.width = 6, dpi = 100, fig.cap = "Figure S5: MA-plots of the normal samples."}
par(mfrow = c(8, 3), mar = c(4, 3, 4, 1))
setmp <- thca.filtered[, thca.filtered$type ==   "normal"]
dgetmp <- dge.subset[, thca.filtered$type ==  "normal"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main = samplename, las = 1)
  abline(h = 0, col = "blue", lwd = 2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col = "red", lwd = 2)
}
```

We do not observe either important expression-level dependent biases among the normal samples.

### Batch identification

We will search now for potential surrogate of batch effect indicators. Given that each sample
names corresponds to a TCGA barcode (see the [wiki](https://wiki.nci.nih.gov/display/TCGA/TCGA+barcode)), following the strategy described [here](http://bioinformatics.mdanderson.org/main/TCGABatchEffects:Overview) we are going to derive different elements of the TCGA barcode and examine their distribution
across samples.

```{r barcodes}
tss <- substr(sample_names, 6, 7)
table(tss)
samplevial <- substr(sample_names, 14, 16)
table(samplevial)
portion <- substr(sample_names, 18, 19)
table(portion)
table(substr(sample_names, 20, 20))
plate <- substr(sample_names, 22, 25)
table(plate)
center <- substr(sample_names, 27, 28)
table(center)
```

We can observe that they come from several tissues source sites, but all from the same center (	
University of North Carolina) and the same metabolite (RNA). However they come from 10 different plates, from 5 portionanalyte and 3 vials.

We are going to check if the TSS as surrogate of batch effect indicator. Considering our outcome
of interest as molecular changes between sample types, tumor vs. normal, we will examine now
the cross-classification of this outcome with the variables:

```{r table.barcodes}
table(data.frame(TYPE = thca.filtered$type, TSS = tss))
# We will check for the other variables
table(data.frame(TYPE = thca.filtered$type, PLATE = plate))
table(data.frame(TYPE = thca.filtered$type, Portion = portion))
table(data.frame(TYPE = thca.filtered$type, Vial = samplevial))
```

To double check if they have some effect on the batch we make the hierarchical clustering of them. First we set some functions to plot the hierarhcical clustering:

```{r clustering.func}
help.dendogram <- function(x, batch, labels) {
    # Helper function to plot dendograms
    if (is.leaf(x)) {
        ## color by batch
        attr(x, "nodePar") <- list(lab.col = as.vector(batch[attr(x, "label")])) 
        ## label by outcome
        attr(x, "label") <- as.vector(labels[attr(x, "label")])
    }
    x
}

plot.batch <- function(dendrogram, batching, se, out){
    # Function to see the batch
    # Given a sampleDendogram use batching to colour the leafs by sample.names of se
    sample.names = colnames(se)
    batch <- as.integer(factor(batching))
    names(batch) <- sample.names
    i.dendrogram <- dendrapply(dendrogram, help.dendogram, batch, out)
    plot(i.dendrogram, main = "Hierarchical clustering")
    legend("topright", paste("Batch", levels(factor(batching))), fill = sort(unique(batch)))
}
```

With this functions to plot the clustering with different labelings is easier:

```{r clustering.n, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap = "Figure S6: Hierarchical clustering of the samples."}
d <- as.dist(1-cor(assays(thca.filtered)$cqn.logCPM, method = "spearman"))
sampleClustering <- hclust(d)
sampleDendrogram <- as.dendrogram(sampleClustering, hang = 0.1)
outcome <- paste(substr(colnames(thca.filtered), 9, 12),
                        as.character(thca.filtered$type), sep = "-")
names(outcome) <- colnames(thca.filtered)
par(mfrow = c(1,1))
plot.batch(sampleDendrogram, portion, thca.filtered, outcome)
plot.batch(sampleDendrogram, samplevial, thca.filtered, outcome)
plot.batch(sampleDendrogram, tss, thca.filtered, outcome)
plot.batch(sampleDendrogram, as.character(thca.filtered$type), thca.filtered, outcome)
```

We can see that the sample from A3PR-normal clusters with the tumoral ones, and the A3H2 tumoral clusters with the healthy patients. 
There might be a batch effect on the samplevial, that is the order of portion in a sequence of 100 - 120 mg sample portions. We can also observe that there are two groups of tumoral samples, and one of them clusters with one sample from a healthy person. We can see with a PCA that the tumoral and normal cells don't create two clearly separated groups:

```{r mds, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap = "Figure S7: Multidimensional scaling plot of the samples."}
for (batching in list(portion, as.character(thca.filtered$type), as.character(thca.filtered$gender))){
    batch <- as.integer(factor(batching))
    names(batch) <- sample_names
    plotMDS(dge.subset, labels = outcome, col = batch)
    legend("bottomleft", paste("Batch", levels(factor(batching))),
           fill = sort(unique(batch)), inset = 0.05, cex=0.7)
}
```

We can confirm that there isn't a clear group of normal and tumors and some tumoral samples do mix with the normal ones. And it seems that the females have more variance between healthy and tumoral.

## Removing batch effect

### ComBat

After the looking for the batch effect we couldn't find the cause of the batch effect, but we try to see if by 
```{r clustering.combat}
combatexp <- ComBat(assays(thca.filtered)$cqn.logCPM, batch)

d <- as.dist(1 - cor(combatexp, method = "spearman"))
cluter.combat <- hclust(d)
cluter.combat <- as.dendrogram(cluter.combat, hang = 0.1)
names(batch) <- colnames(thca.filtered)
outcome <- paste(substr(colnames(thca.filtered), 9, 12),
                            as.character(thca.filtered$type), sep = "-")
names(outcome) <- colnames(thca.filtered)

plot.batch(cluter.combat, samplevial, thca.filtered, outcome)
plot.batch(cluter.combat, thca.filtered$gender, thca.filtered, outcome)
plot.batch(cluter.combat, thca.filtered$type, thca.filtered, outcome)
```

We can observe a slightly improvement, but still some tumoral samples cluster together with the normal ones. 

### QR Decomposition

To improve the batch effect removal we look if QR decomposition yields better results:

```{r clustering.QRdecomposition}
library(limma)
batch <- as.integer(as.factor(tss))
qrexp <- removeBatchEffect(assays(thca.filtered)$cqn.logCPM, batch, design = mod)
d <- as.dist(1 - cor(qrexp, method = "spearman"))
cluster.qr <- hclust(d)
cluster.qr <- as.dendrogram(cluster.qr, hang = 0.1)

plot.batch(cluster.qr, samplevial, thca.filtered, outcome)
plot.batch(cluster.qr, tss, thca.filtered, outcome)
plot.batch(cluster.qr, thca.filtered$gender, thca.filtered, outcome)
plot.batch(cluster.qr, thca.filtered$type, thca.filtered, outcome)

```

With QR decomposition we can observe that just one normal sample clusters with tumoral ones,  and we can't observe other factor influencing this clustering.

### Removing batch effect with SVD

We further try if SVD returns a better result:

```{r clustring.svd}
library("corpcor")
s <- fast.svd(t(scale(t(assays(thca.filtered)$cqn.logCPM), center = TRUE, scale = TRUE)))
pcSds <- s$d
pcSds[1] <- 0
svdexp <- s$u %*% diag(pcSds) %*% t(s$v)
colnames(svdexp) <- colnames(thca.filtered)
class(svdexp)
dim(svdexp)

d <- as.dist(1 - cor(svdexp, method = "spearman"))
cluster.svd <- hclust(d)
cluster.svd <- as.dendrogram(cluster.svd, hang = 0.1)
names(batch) <- colnames(thca.filtered)

plot.batch(cluster.svd, samplevial, thca.filtered, outcome)
plot.batch(cluster.svd, tss, thca.filtered, outcome)
plot.batch(cluster.svd, thca.filtered$type, thca.filtered, outcome)
```

SVD clusters together normal and tumoral samples, maybe because some of them are quite similar according to the PCA previously performed.
After all 
## Differential expression

We perform a simple examination of expression changes and their associated p-values
using the R/Bioconductor package [sva](http://bioconductor.org/packages/sva).

```{r sva.model, cache=TRUE}
library(sva)
variables0 <- colnames(filtered) # All variables available
variables <- c("gender", "type") # Variables for the model
form <- as.formula(paste("~ ", paste(variables, collapse = "+"))) # Building the model
mod  <- model.matrix(form, data=colData(thca.filtered)[, variable.info > 0.6])
mod0 <- model.matrix(~ 1 , data=colData(thca.filtered)[, variable.info > 0.6])
pv <- f.pvalue(assays(thca.filtered)$cqn.logCPM, mod, mod0)
sum(p.adjust(pv, method = "fdr") < 0.01)
```

There are `r sum(p.adjust(pv, method = "fdr") < 0.01)` genes changing significantly
their expression at FDR < 1%. In Figure S8 below we show the distribution of the
resulting p-values.

```{r pdist, out.width = "400px", fig.cap = "Figure S8: Distribution of raw p-values for an F-test on every gene between tumor and normal samples."}
hist(pv, main = "", las = 1)
```

Now, let's estimate surrogate variables using the `sva()` function.

```{r sva.variables}
sv <- sva(assays(thca.filtered)$cqn.logCPM, mod, mod0)
sv$n
```

The SVA algorithm has found `r sv$n` surrogate variables. Let's use them to
assess against the extent of differential expression this time adjusting for these
surrogate variables.

```{r svn.ftest}
modsv <- cbind(mod, sv$sv)
mod0sv <- cbind(mod0, sv$sv)
pvsv <- f.pvalue(assays(thca.filtered)$cqn.logCPM, modsv, mod0sv)
sum(p.adjust(pvsv, method = "fdr") < 0.01)
```

We have increased the number of changing genes to `r sum(p.adjust(pvsv, method = "fdr") < 0.01)`.
Figure S9 shows the resulting distribution of p-values.

```{r psvdist, out.width = "400px", fig.cap = fig$cap("Figure S9","Distribution of raw p-values for an F-test on every gene between tumor and normal samples, adjusting for surrogate variables estimated with SVA.")}
hist(pvsv, main = "", las = 1)
```


## SessionInfo

```{r sessionInfo}
sessionInfo()
```

##Bibliography

* Agrawal N, Akbani R, Aksoy BA, Ally A, Arachchi H, Asa SL, Zou L. (2014). Integrated Genomic Characterization of Papillary Thyroid Carcinoma. Cell, 159(3), 676-690. 
* The Canger Genome Atlas. Papillary Thyroid Carcinoma. Retrieved May 6, 2016. Available from: http://cancergenome.nih.gov/cancersselected/thyroid
* Xing M. (2013). Molecular pathogenesis and mechanisms of thyroid cancer. Nature Reviews. Cancer, 13(3), 184-99. 
