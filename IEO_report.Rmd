---
title: "Analysis of a TCGA RNA-seq data set on Thyroid carcinoma (THCA)"
output:
  html_document:
    toc: true
    theme: united
  pdf_document:
    toc: true
---
```{r setup, cache = TRUE, echo = FALSE, results = 'asis'}
library("knitr")
dumpcssfile <- function(fname) {
  paste(c('<style type = "text/css">', readLines(fname), '</style>\n'),
        collapse = "\n")
}

opts_chunk$set(cache = TRUE,
               autodep = TRUE,
               fig.align = "center",
               comment = "",
               tidy = TRUE,
               message = FALSE,
               source = function(x, options) {
    paste("\\begin{lstlisting}[numbers=left, firstnumber=last]\n", x, 
        "\\end{lstlisting}\n", sep = "")
}) 
# Some modifications from http://stackoverflow.com/a/27633734/2886003

knit_hooks$set(error = function(x, options) stop(x),
               fig.cap = function(before, options, envir) {
                 if (!before) {
                   paste0('<p class = "caption">', options$fig.cap, "</p>")
                 }
               })

# Modifications based on https://rpubs.com/ajlyons/autonumfigs
# A function for generating captions and cross-references
fig <- local({
    i <- 0
    list(
        cap=function(refName, text, center=FALSE, col="black", inline=FALSE) {
            i <<- i + 1
            ref[[refName]] <<- i
            css_ctr <- ""
            if (center) css_ctr <- "text-align:center; display:inline-block; width:100%;"
            cap_txt <- paste0("<span style=\"color:", col, "; ", css_ctr, "\">Figure ", i, ": ", text , "</span>")
            anchor <- paste0("<a name=\"", refName, "\"></a>")
            if (inline) {
                paste0(anchor, cap_txt)    
            } else {
                list(anchor=anchor, cap_txt=cap_txt)
            }
        },
        
        ref=function(refName, link=FALSE, checkRef=TRUE) {
            
            ## This function puts in a cross reference to a caption. You refer to the
            ## caption with the refName that was passed to fig$cap() (not the code chunk name).
            ## The cross reference can be hyperlinked.
            
            if (checkRef && !refName %in% names(ref)) stop(paste0("fig$ref() error: ", refName, " not found"))
            if (link) {
                paste0("<A HREF=\"#", refName, "\">Figure ", ref[[refName]], "</A>")
            } else {
                paste0("Figure ", ref[[refName]])
            }
        },
        
        ref_all=function(){
            ## For debugging
            ref
        })
})

## This chunk replaces the default hook for processing plots. It achieves the purposes,
## of laying out auto-numbered captions, but other functionality may be gone.
knit_hooks$set(plot = function(x, options) {
    sty <- ""
    if (options$fig.align == 'default') {
        sty <- ""
    } else {
        sty <- paste0(" style=\"text-align:", options$fig.align, ";\"")
    }
    
    if (is.list(options$fig.cap)) {
        ## options$fig.cap is a list returned by the function fig$cap()
        str_caption <- options$fig.cap$cap_txt
        str_anchr <- options$fig.cap$anchor
    } else {
        ## options$fig.cap is a character object (hard coded, no anchor)
        str_caption <- options$fig.cap
        str_anchr <- ""
    }
    
    paste('<figure', sty, '>', str_anchr, '<img src="',
        opts_knit$get('base.url'), paste(x, collapse = '.'),
        '"><figcaption>', str_caption, '</figcaption></figure>',
        sep = '')
    
})

## This chunck will read through *this* Rmd file, and attempt to extract all of the 
## labels (not caption text) used for Figure captions. These labels are used
## as anchors, so scanning through the document now will allow us to create cross references
## before the caption actually appears. 

## Get the name of this Rmd file
rmdFn <- knitr::current_input()  # filename of input document

## Read lines and close connection
rmdCon <- file(rmdFn, open = "r")
rmdLines <- readLines(rmdCon)
close(rmdCon)

## Pull out all occurences of at least one back tick, followed 
## by any number of characters, followed by fig$cap (all on one line)
figscap_idx <- grep("`+(.*)fig\\$cap", rmdLines)
rmdLines <- rmdLines[figscap_idx]

## Get rid of everything up until the start of the caption label
## This presumes the caption label is the first argument of fig$cap()
## E.g., fig.cap = fig$cap("my_label", ...)
rmdLinesSansPre <- sub("(.*)fig\\$cap(.*?)[\"']", "", rmdLines)

## Identify everything up until the first quote
match_data <- regexpr("(.*?)[\"']", rmdLinesSansPre)

## Reduce the length by one, because we're not interested in the final quote
attr(match_data, "match.length") <- attr(match_data, "match.length") - 1

## Extract
fig_labels <- regmatches(rmdLinesSansPre, match_data, invert=FALSE)

if (length(fig_labels) > 0) {

    ## Test for duplicates
    if (anyDuplicated(fig_labels) > 0) stop("Duplicate caption labels detected")
    
    ## Create a named list of Figure numbers
    ref <- as.list(1:length(fig_labels))
    names(ref) <- fig_labels
}    

cat(dumpcssfile(file.path("css", "ieo.css")))
```

#### Mauro Álvarez (mauro.alvarez01@estudiant.upf.edu)
#### Lluís Revilla(lluis.revilla01@estudiant.upf.edu)
#### Marina Reixachs (marina.reixachs01@estudiant.upf.edu)
#### Inés Sentís (ines.sentis01@estudiant.upf.edu) 

## Introduction

Thyroid cancer can develop from the different cells that form the follicles of the thyroid. This gland located at the base of the throat secretes hormones such as T3 and T4 that have their metabolic functionalities such as control of heart rate, blood pressure, body temperature and weight. [See it on TCGA](http://cancergenome.nih.gov/cancersselected/thyroid). 

From the four types of thyroid cancer (papillary, follicular, medullary, and anaplastic thyroid cancer) Papillary Thyroid Carcinoma (PTC) is the most common type of thyroid cancer (Agrawal et al., 2014). It is more prevalent in women than men and its common diagnosis occurs around 49 years old.

Driver onco-mutations for this type of cancer appear as alterations of the MAPK signaling pathway and the PI3K-AKT pathway (Agrawal et al., 2014). Both are implied in cell proliferation and survival and in human tumorigenesis. The overactivation of the MAPK pathway because of mutations such as the BRAFV600E mutation, leads to the development of papillary thyroid cancer (PTC) from follicular thyroid cells (Xing, 2013). On the other hand, mutations that activate the PI3K-AKT pathway, such as mutations in RAS, PTEN and PIK3CA, mostly leads to development of follicular thyroid adenoma (FTA) and follicular thyroid cancer (FTC) also in follicular thyroid cells (Xing, 2013).

Research from The Cancer Genome Atlas [(TCGA)](http://cancergenome.nih.gov/cancersselected/thyroid) focused on PTC and they found that a part from alterations in BRAF (specifically BRAFV600E) and RAS, there are other driver mutations such the ones in EIF1AX PPM1D, and CHEK2 genes that are main alterations for that type of thyroid cancer(Agrawal et al., 2014).

## Data import

We start importing the raw table of counts.

```{r start, message=FALSE}
library(SummarizedExperiment)

thca <- readRDS("seTHCA.rds") 
thca
```

Explore the column (phenotypic) data, which in this case corresponds to clinical
variables, and their corresponding metadata.

```{r explore1}
dim(colData(thca))
col.data <- colData(thca)
col.data[1:5, 1:5]

col.data.meta <- mcols(colData(thca), use.names=TRUE)
col.data.meta
```

Now, explore the row (feature) data.

```{r explore2}
row.ranges <- rowRanges(thca)
row.ranges
```

Looking deeper into col.data with:

```{r explore.col.data}
col.data[1:5, 30:35]
```

We observed that there are different ways to indicate that the data is not available (NA, [Not Available]...). Consequently, we decide to study which variables have more information. To do so, we create two functions, one (`na.replace`) to change those values into the standarized `NA` nomenclature, and `filter.info` to quantify how many of each variable is not `NA`.

```{r functions}

na.replace <- function(x){
    # Remove the unwanted factors
    lev <- levels(x)
    lev <- lev[!(lev %in% "[Not Available]")]
    lev <- lev[!(lev %in% "[Unknown]")]
    lev <- lev[!(lev %in% "[Not Applicable]")]
    lev <- lev[!(lev %in% "[Not Available]|[Not Available]|[Not Available]")]
    lev <- lev[!(lev %in% "[Not Evaluated]")]
    lev <- lev[!(lev %in% "None")]

    x <- factor(x, levels=lev)
}

filter.info <- function(x){
    # Function to filter the NA, [Not Available], [Not Applicable] and [Unknown]
    # Return the proportion of information on x
    nas <- sum(is.na(x))
    return(1 - (nas/length(x)))
}
```

We apply these functions to the `col.data` and we visualize it:

```{r col.data.analysis, fig.cap="\\label{fig:col.data.analysis}Figure 1."}
meta.info <- as.data.frame(lapply(col.data, na.replace))
variable.info <- sapply(meta.info, filter.info)

# Representing the information by column vs total information
relative.info <- variable.info[order(variable.info)]/sum(variable.info)
plot(relative.info, main="Information brought by column")
```
```{r col.data.analysis2, fig.cap="\\label{fig:col.data.analysis2}Figure 2.A"}
# Plotting the histogram of the information
hist(variable.info, 
     main = "Variables completness", xlab = "% of not NA of each variable", ylab = "Counts")
```
```{r col.data.analysis3, fig.cap="\\label{fig:col.data.analysis3}Figure 2.B"}
# Seeing the most informative to set a threshold,
# frequency are the number of columns with such % of information
hist(variable.info, xlim = c(0.3, 1), ylim = c(0, 35), 
     main = "Variables completness", xlab = "% of not NA of each variable", ylab = "Counts")
```

As we can see, in many variables the main value is just `NA` or other derivatives meaning "No information available for this variable". Therefore, in order to keep the most informative variables, we apply a threshold of 60% (of the values containing informative data) to select the relevant ones:

```{r select.filtered}
filtered <- meta.info[, variable.info  > 0.6]

dim(filtered)
meta.info.summary2 <- col.data.meta[variable.info  > 0.6,]
```

To explore the data we first create an object with `ggplot`:
```{r ggplot.config}
library("ggplot2")
fplot <- ggplot(as.data.frame(filtered))

## ggplot options for axes and background color
# Options of the labels
l <- theme(axis.text.x=element_text(angle = -90, hjust = 0, vjust = 1))
# Removing the background
b <-  theme(axis.line = element_line(colour = "black"),
            panel.grid.major.x = element_blank(),
            panel.grid.major.y = element_line(colour = "grey", size = 0.5, linetype = 2),
            panel.grid.minor.y = element_line(colour = "grey", size = 0.25, linetype = 3),
            panel.border = element_blank(),
            panel.background = element_blank())
y.axis <- ylab("number of cases")

```

And we plot some relationships for some significant variables:
In the "normal" type samples most of the information is not available. This could be due to the fact that all "normal" samples were obtained from patients with tumors. So in order to have the maximum information of each sample, we infer "normal" samples information from its paired sample data (mainly gender and ethnicity).

And we plot some relationships for some significant variables:
In the "normal" type samples most of the information is not available. This could be due to the fact that all "normal" samples were obtained from patients with tumors. So in order to have the maximum information of each sample, we infer "normal" samples information from its paired sample data (mainly gender and ethnicity).

```{r plots3A, fig.cap="\\label{fig:plots3A}Figure 3.A"}
fplot + geom_bar(aes(type, fill = gender)) + b + y.axis + 
    ggtitle("Gender distribution across normal and tumour samples")
```
As expected, there are more female samples than male samples. As we mentioned before, thyroid cancer is more prevalent in women than men and we can see that not only for tumor samples but for normals samples too. In addition, there are more tumor cases than normal cases.
```{r plots3B,fig.cap="\\label{fig:plots3B}Figure 3.B"}
fplot + geom_bar(aes(type, fill = tumor_status)) + b + y.axis + 
    ggtitle("Tumor status across normal and tumour samples")
```
We also have examined the tumor status of the tumor samples. There are more cancer patients without tumor ("tumor free") than with the tumor ("with tumor") after the collection of the data. We assume that most of the patients that participate in the study have recovered after it. 
```{r plots3C, fig.cap="\\label{fig:plots3C}Figure 3.C"}
fplot + facet_wrap(~ gender) + geom_bar(aes(type, fill = ethnicity)) + b + 
    y.axis + ggtitle("Ethnicity distribution across normal and tumour samples")
```
In this plot we can see clearly the lack of data for some variables regarding normal samples. In other words, there is no record for normal samples neither females nor males about the hispanic origin of the individuals.
```{r plots3D, fig.cap="\\label{fig:plots3D}Figure 3.D"}
labels <- c("AM. INDIAN OR ALASKA NAT.", "ASIAN", "BLACK OR AFRICAN AM.", 
            "WHITE", "NA")
fplot + facet_wrap(~ ethnicity) + geom_bar(aes(ethnicity, fill = gender)) + b +
    l + y.axis + scale_x_discrete(breaks=waiver(), labels = labels) +
    ggtitle("Gender distribution across different ethnicity and race.")
```
If we have a look at the ethnicities, gender and hispanic origin, the data shows more cases for "white" individuals "not hispanic or latino" than "white" individuals hispanic or latino.
```{r plots3E, fig.cap="\\label{fig:plots3E}Figure 3.E"}
fplot + geom_bar(aes(x=gender, fill = race)) + b + y.axis + 
    ggtitle("Ethnicity distribution in male and female")
```
If we ignore the hispanic origin of the individuals and just focus on the main ethnicities of the study we can observe that for both female and male samples there is  a majority of "white" individuals. However, the fact that "white" subjects are hispanic or not can provide some variability so that is something we will take into account later. 
```{r plots3F, fig.cap="\\label{fig:plots3F}Figure 3.F"}
fplot + facet_wrap(~ type ) + geom_bar(aes(tumor_focality, fill = gender)) + b +
    l + y.axis + xlab("tumor focality") + ggtitle("Gender distribution in different tumour focality")
```
There is no data about tumor focality in the normal samples... 
```{r plots3G, fig.cap="\\label{fig:plots3G}Figure 3.G"}
labels <- c("Other specify", "Papillary - Classical", "Papillary - Follicular", 
            "Papillary - Tall Cell", "NA")
hd.xaxis <-  scale_x_discrete(name = "histologic diagnosis", breaks=waiver(), 
                labels=labels)
fplot + geom_bar(aes(histologic_diagnosis, fill = gender)) + b + l + hd.xaxis + 
    y.axis + 
    ggtitle("Gender distribution across different types of hystologic diagnosis")
```
Here, we can see that the tumor samples came mainly from classical Papillary Thyroid Carcinoma. We expect differential expression between the different thyroid cancer phenotypes so this might be a source of variability.
```{r plots3H, fig.cap="\\label{fig:plots3H}Figure 3.H", fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE}
labels <- c("Other specify", "Papillary - Classical", "Papillary - Follicular", 
            "Papillary - Tall Cell", "NA")
ggplot(filtered[!is.na(filtered$age_at_diagnosis), ]) + 
    geom_bar(aes(age_at_diagnosis, na.rm = TRUE, fill = histologic_diagnosis)) +
    b + l + labs(x="age at diagnosis") + y.axis + 
    scale_fill_discrete(name = "histologic diagnosis", breaks = waiver(), 
    labels = labels) + ggtitle("Histologic diagnosis distribution across different ages")
```
Even thought, thyroid cancer is commontly diagnosed at mature ages (~50) this plot shows that the classical papillary thyroid cancer has similar representation in all ages for this dataset.

As a summary from the previous plots, the most abundant population in the samples is the "white" and "not hispanic or latino", so we decide to perform the analysis on this group of individuals, whose tumoral sample correspond to the most common cancer in thyroids: Papillary Thyroid Carcinoma(PTC). With this approach we want to avoid to include in the analysis, samples that introduce variability (mainly differential expression due to enviromental or epigenetic factors) as much as possible. To have more insight on the disease we want to have just paired samples, that is, samples from the same participant. So we filter the data accordingly:

```{r subset}
# Paired data
paired <- intersect(thca[, thca$type == 'tumor']$bcr_patient_barcode, 
                    thca[, thca$type == 'normal']$bcr_patient_barcode)
paired_mask <- thca$bcr_patient_barcode %in% paired

filtered_filt <- filtered[paired_mask, ]

# Imposing the selected conditions
tumor_names <- row.names(subset(filtered_filt, type == "tumor" &
                                race == "WHITE" &
                                histologic_diagnosis == "Thyroid Papillary Carcinoma - Classical/usual" &
                                ethnicity == "NOT HISPANIC OR LATINO" ))

# Extracting the participants identifiers
participants <- unlist(lapply(tumor_names, substr, 9, 12))
participants <- participants[participants != ""]

check <- function(x, checklist){
    # Returning name of the sample just if the name is the same as in checklist
    a <- substr(x, 9, 12)
    if(a %in% checklist){
        return(x)
    }
}

# Extracting sample names of tumor and normal data.
sample_names <- unlist(lapply(row.names(filtered_filt), check, 
                              checklist = participants))
thca.filtered <- thca[, sample_names]

#Imposing known col.Data in paired normal samples
filtered_filt$race <- replace(filtered_filt$race, 
                          which(is.na(filtered_filt$race)), "WHITE")
filtered_filt$ethnicity <- replace(filtered_filt$ethnicity, 
                               which(is.na(filtered_filt$ethnicity)), "NOT HISPANIC OR LATINO")
```

We explore again the variables for this subset. In this case, we show just some of the relationship plots we have seen previously:
```{r subset.explore1, fig.cap="\\label{fig:subset.explore1}Figure 4.A"}
filtered_filt <- filtered_filt[row.names(filtered_filt) %in% sample_names, ]
mplot <- ggplot(filtered_filt) + y.axis
mplot + geom_bar(aes(type, fill = gender)) + b +
  ggtitle("Ethnicity and type of sample after filtering")
```
This plot just checks whether we have the same number of cases in normal sample and tumor sample so that we have done correctly the filtering.
```{r subset.explore2, fig.cap="\\label{fig:subset.explore2}Figure 4.B"}
mplot + facet_wrap(~ gender) + geom_bar(aes(type, fill = ethnicity)) + b +
  ggtitle("Hispanic origin, gender and type of sample after filtering")
```
Hispanic origin data is only available for tumor samples but as we have mentioned before we can extrapolate ethinicity and origin to the normal samples because they are paired (see below). 
```{r subset.explore3, fig.cap="\\label{fig:subset.explore3}Figure 4.C"}
mplot + geom_bar(aes(x=gender, fill = ethnicity)) + b + l +
  ggtitle("Gender samples and hispanic origin after filtering")
```
Same proportion of being or not being "hispanic or latino" in females and males. Subset filtering has not modified the fact that we have more female samples than males. 
```{r subset.explore4, fig.cap="\\label{fig:subset.explore4}Figure 4.D"}
mplot + geom_bar(aes(histologic_diagnosis, fill = gender)) + b + l + 
    scale_x_discrete(name = "histologic diagnosis", breaks=waiver(), 
    labels = c("Papillary - Classical", "NA")) + 
    ggtitle("Gender distribution across different types of hystologic diagnosis after filtering")
```
Papillary Classical Thyroid cancer in the same proportion as "NA" because we have the same number of normal cases and classical thyroid tumor cases. 
```{r subset.explore5, fig.cap="\\label{fig:subset.explore5}Figure 4.E"}
ggplot(filtered_filt[!is.na(filtered_filt$age_at_diagnosis), ]) +
    geom_bar(aes(age_at_diagnosis, fill = histologic_diagnosis)) + b + l + y.axis +
    xlab("age at diagnosis") + scale_fill_discrete(name = "histologic diagnosis",
    breaks=waiver(), labels = c("Papillary - Classical", "NA")) + 
    ggtitle("Histologic diagnosis distribution across different ages after filtering")
```
Number of cases across ages is more or less similar after the filtering exept for some ages that have more cases around 30, 34, 42 and 47. 

To perform quality assessment and normalization we need first to load the
[edgeR](http://bioconductor.org/packages/edgeR) R/Bioconductor package and
create a `DGEList' object.

```{r edgeR, message = FALSE}
library(edgeR)

# Normalization just with the selected samples
dge.subset <- DGEList(counts=assays(thca.filtered)$counts, genes=mcols(thca.filtered))
dge <- DGEList(counts=assays(thca)$counts, genes=mcols(thca))
```

Now calculate $\log_2$ CPM values of expression and put them as an additional
assay element to ease their manipulation.

```{r logCPM}
assays(thca.filtered)$logCPM <- cpm(dge.subset, log=TRUE, prior.count=3)
assays(thca.filtered)$logCPM[1:5, 1:5]
logCPM <- assays(thca.filtered)$logCPM
```

## Quality assessment and normalization

### Library sizes

Let's examine the library sizes in terms of total number of sequence read counts
per sample. Figure 5 below shows library sizes per sample in increasing order.

<!---
you can control the height and width in pixels of the figure with 'out.height' and 'out.width'
--->

```{r libsizes1, echo=FALSE, out.width="600px", fig.cap="Figure 5.A: Library sizes in increasing order."}
ord <- order(dge$sample$lib.size/1e6)
barplot(dge$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads",
        xlab="Samples", col=c("blue", "red")[(thca$type[ord] == "tumor") + 1])
legend("topleft", c("tumor", "normal"), fill=c("red", "blue"), inset=0.01)
```
Plotting for all samples makes it impossible to see accurately the blue and red colors corresponding to tumor and normal respectively.
```{r libsizes2, echo=FALSE, out.width="600px", fig.cap="Figure 5.B: Library sizes in increasing order."}
ord.subset <- order(dge.subset$sample$lib.size/1e6)
barplot(dge.subset$sample$lib.size[ord.subset]/1e6, las=1, ylab="Millions of reads",
        xlab="Samples", col=c("blue", "red")[(thca.filtered$type[ord.subset] == "tumor") + 1])
legend("topleft", c("tumor", "normal"), fill=c("red", "blue"), inset=0.01)
```
After the filtering the subset plot allows one to see that there is similar heterogeneity in tumor and normal library sizes. In addition, this figure reveals substantial differences in sequencing depth between samples and we may consider discarding those samples whose depth is substantially lower than the rest. To identify which are these samples we may simply look at the
actual numbers including portion of the sample identifier that distinguishes them.

```{r libsize.set, fig.cap="\\label{fig:libsize.set}Figure 6." }
sampledepth <- round(dge.subset$sample$lib.size / 1e6, digits = 1)
names(sampledepth) <- substr(sample_names, 6, 12)

qqnorm(sampledepth)
qqline(sampledepth)
```

Looking into the qqplot we decide to filter out those below 40 or above 70 but keeping only those that are paired:

```{r refiltering.names}
sample_names <- sample_names[sampledepth > 40 & sampledepth < 70]

keep.paired <- function(pattern, x){
    # Return the names if it is paired
    pos <- grep(pattern, x, fixed = TRUE)
    if (length(pos) > 1){
        return(x[pos])
    }
}

sample_names <- unique(unlist(lapply(substr(sample_names, 9, 12), 
                                     keep.paired, sample_names)))

thca.filtered <- thca.filtered[, colnames(thca.filtered) %in% sample_names]
dge.subset <- DGEList(counts=assays(thca.filtered)$counts, 
                      genes=mcols(thca.filtered))
```

### Distribution of expression levels among samples

Let's look at the distribution of expression values per sample in terms of
logarithmic CPM units. Due to the large number of samples, we display tumor
and normal samples separately, and are shown in Figure 7.

<!---
the option echo = FALSE hides the R code. When plotting in general one does not
want to see the code. Options fig.height and fig.width control height and width
of the plot in inches while out.height and out.width do it in the final output
file; see http://yihui.name/knitr/options for full details.
--->

```{r distRawExp, fig.height = 4, fig.width = 10, out.width = "800px", fig.cap="\\label{fig: distRawExp}Figure 7:Non-parametric density distribution of expression profiles per sample.", message=FALSE}
library(geneplotter)
par(mfrow = c(1, 2))
multidensity(as.list(as.data.frame(assays(thca.filtered[, 
            thca.filtered$type ==  "tumor"])$logCPM)),
            xlab = "log 2 CPM", legend = NULL, main = "Tumor samples", 
            las = 1)
multidensity(as.list(as.data.frame(assays(thca.filtered[,
            thca.filtered$type ==  "normal"])$logCPM)),
            xlab = "log 2 CPM", legend = NULL, main = "Normal samples",
            las = 1)
```

Seeing this plots we suspect the two spikes are due to the effect of the read length and GC content of each transcript. Therefore we will correct them with the package cqn:

```{r cqn, message=FALSE}
library("cqn")
cqn.subset <- cqn(assays(thca.filtered)$counts, 
                  lengths = rowRanges(thca.filtered)$txlen,
                  x = rowRanges(thca.filtered)$txgc,
                  sizeFactors = colSums(assays(thca.filtered)$counts))
par(mfrow=c(1,2))
cqnplot(cqn.subset, n = 1, xlab = "GC content", lty = 1)
cqnplot(cqn.subset, n = 2, xlab = "length", lty = 1)
```

The plot shows more variance on the extreme values of GC content and length, and more variability due to length than due to GC.

We can see if the distribution of expression values per sample in terms of logarithmic CPM units. Due to the large number of samples, we display tumor and normal samples separately:

```{r distExp, fig.height = 4, fig.width = 10, out.width = "800px", fig.cap = "Figure 8: Non-parametric density distribution of expression profiles per sample."}
cqn.logCPM <- cqn.subset$y + cqn.subset$offset
assays(thca.filtered)$cqn.logCPM <- cqn.logCPM
par(mfrow = c(1, 2))
multidensity(as.list(as.data.frame(
    cqn.logCPM[,thca.filtered$type ==  "tumor"])),
     xlab = "log 2 CPM", legend = NULL, main = "Tumor samples", las = 1)
multidensity(as.list(as.data.frame(
    cqn.logCPM[, thca.filtered$type ==  "normal"])),
    xlab = "log 2 CPM", legend = NULL, main = "Normal samples", las = 1)
```

These "after-normalization" plots are quite better than the previous ones used without GC and length normalization on the second spike. With this normalization we do not appreciate substantial differences between the samples in the distribution of expression values. However, below 0 there is a lot of variability.

### Distribution of expression levels among genes

Let's calculate now the average expression per gene through all the samples. Figure 9
shows the distribution of those values across genes.

```{r exprdist, out.width = "400px", fig.cap = "Figure 9: Distribution of average expression level per gene."}
par(mfrow = c(1, 2))
avgexp <- rowMeans(assays(thca.filtered)$logCPM)
hist(avgexp, xlab = "log2 CPM", main = "Using DGEList normalization", las = 1)
abline(v = 1, col = "red", lwd = 2)

# Using the corrected logCPM
avgexp.cqn <- rowMeans(assays(thca.filtered)$cqn.logCPM)
hist(avgexp.cqn, xlab = "log2 CPM", main = "Using cqn normalization", las = 1)
abline(v = 1, col = "red", lwd = 2)
```

### Filtering of lowly-expressed genes

In the light of previous plot, we may consider a cutoff of 1 log CPM unit as minimum value
of expression to select genes being expressed across samples. Using this cutoff we proceed
to filter out lowly-expressed genes.

```{r filter.low.expr}
mask <- avgexp.cqn > 1
sum(mask)
thca.filtered <- thca.filtered[mask, ]
dge.subset <- dge.subset[mask, ]
```

### Normalization

Since we will use the offsets computed by `cqn`, there is no need to normalize using the normalization tools from `edgeR`, such as `calcNormFactors` according to cqn vignette.

```{r norm, fig.cap="\\label{fig: norm}Figure10: Tumor and Normal samples after filtering, without normalization, with calcNormFactors normalization and with cqn normalization " }
dge.subset$offset <- cqn.subset$glm.offset

dge.norm <- calcNormFactors(dge.subset)
assays(thca.filtered)$n.logCPM <- cpm(dge.norm, log = TRUE, prior.count = 3)

par(mfrow = c(3, 2))

# Not normalized but filtered
multidensity(as.list(as.data.frame(
    assays(thca.filtered[,thca.filtered$type ==  "tumor"])$logCPM)),
     xlab = "log 2 CPM", legend = NULL, main = "Tumor samples", las = 1)
multidensity(as.list(as.data.frame(
    assays(thca.filtered[,thca.filtered$type ==  "tumor"])$logCPM)),
    xlab = "log 2 CPM", legend = NULL, main = "Normal samples", las = 1)

# Normalize with calcNormFactors after filtering out those
multidensity(as.list(as.data.frame(
    assays(thca.filtered[,thca.filtered$type ==  "tumor"])$n.logCPM)),
     xlab = "log 2 CPM", legend = NULL, main = "Tumor samples", las = 1)
multidensity(as.list(as.data.frame(
    assays(thca.filtered[,thca.filtered$type ==  "tumor"])$n.logCPM)),
    xlab = "log 2 CPM", legend = NULL, main = "Normal samples", las = 1)

# Normalized with cqn and filtered the low values:
multidensity(as.list(as.data.frame(
    assays(thca.filtered[,thca.filtered$type ==  "tumor"])$cqn.logCPM)),
     xlab = "log 2 CPM", legend = NULL, main = "Tumor samples", las = 1)
multidensity(as.list(as.data.frame(
    assays(thca.filtered[,thca.filtered$type ==  "tumor"])$cqn.logCPM)),
    xlab = "log 2 CPM", legend = NULL, main = "Normal samples", las = 1)
```
The normalization after filtering lowly-expressed genes with 'cqn' package clusters samples into one thin gaussian curve whereas normalization with calcNormFactors makes it thiker. 

### MA-plots

We examine now the MA-plots of the normalized expression profiles. We look first to
the tumor samples.

<!---
Here we make a MA-plot for each sample. The options 'fig.height' and 'fig.width'
control the relative image size in *inches*. The final image size results from
'height'x'dpi' and 'width'x'dpi', where 'dpi' is the image resolution in
"dots per inch" (by default dpi = 72). To scale the image to a desired size use
'out.width' and 'out.height'. More information at http://yihui.name/knitr/options
--->

```{r maPlotsTumor, fig.height = 16, fig.width = 6, dpi = 100, fig.cap = "Figure 11: MA-plots of the tumor samples."}
par(mfrow = c(8, 3), mar = c(4, 3, 4, 1))
setmp <- thca.filtered[, thca.filtered$type ==  "tumor"]
dgetmp <- dge.subset[, thca.filtered$type ==  "tumor"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$cqn.logCPM)
  M <- assays(setmp)$cqn.logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main = samplename, las = 1)
  abline(h = 0, col = "blue", lwd = 2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col = "red", lwd = 2)
}
```

We do not observe samples with major expression-level dependent biases. Let's look now to the normal samples.

```{r maPlotsNormal, fig.height = 16, fig.width = 6, dpi = 100, fig.cap = "Figure 12: MA-plots of the normal samples."}
par(mfrow = c(8, 3), mar = c(4, 3, 4, 1))
setmp <- thca.filtered[, thca.filtered$type ==   "normal"]
dgetmp <- dge.subset[, thca.filtered$type ==  "normal"]
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$cqn.logCPM)
  M <- assays(setmp)$cqn.logCPM[, i] - A
  samplename <- substr(as.character(setmp$bcr_patient_barcode[i]), 1, 12)
  smoothScatter(A, M, main = samplename, las = 1)
  abline(h = 0, col = "blue", lwd = 2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col = "red", lwd = 2)
}
```

We do not observe either important expression-level dependent biases among the normal samples.

### Batch identification

We will search now for potential surrogate of batch effect indicators. Given that each sample
names corresponds to a TCGA barcode (see the [wiki](https://wiki.nci.nih.gov/display/TCGA/TCGA+barcode)), following the strategy described [here](http://bioinformatics.mdanderson.org/main/TCGABatchEffects:Overview) we are going to derive different elements of the TCGA barcode and examine their distribution
across samples.

```{r barcodes}
tss <- substr(sample_names, 6, 7)
table(tss)
samplevial <- substr(sample_names, 14, 16)
table(samplevial)
portion <- substr(sample_names, 18, 19)
table(portion)
table(substr(sample_names, 20, 20))
plate <- substr(sample_names, 22, 25)
table(plate)
center <- substr(sample_names, 27, 28)
table(center)
```

We can observe that the samples where collected at 4 tissues source sites but the majority of them at University of Pittsburg (BJ) and MD Anderson(EL). However,the manager center of the data is the same (University of North Carolina) and the same metabolite (RNA). In addition, they come from 7 different plates more or less distributed. However, most samples came from 2 out of 5 different portion    and 2 out of 3 vials.

We are going to check if the previous variables of the barcode are surrogate of batch effect indicator. Considering our outcome
of interest as molecular changes between sample types, tumor vs. normal, we will examine now
the cross-classification of this outcome with the variables:

```{r table.barcodes}
table(data.frame(TYPE = thca.filtered$type, TSS = tss))
# We will check for the other variables
table(data.frame(TYPE = thca.filtered$type, PLATE = plate))
table(data.frame(TYPE = thca.filtered$type, Portion = portion))
table(data.frame(TYPE = thca.filtered$type, Vial = samplevial))
```
From the tables we can already see that all of them can be candidates as indicators for batch effect as there is no homogeneity of the number of tumor and normal samples across any of the variables. 

To double check if they have some effect on the batch we make the hierarchical clustering of them. First, we set some functions to plot the hierarhcical clustering:

```{r clustering.func}
help.dendogram <- function(x, batch, labels) {
    # Helper function to plot dendograms
    if (is.leaf(x)) {
        ## color by batch
        attr(x, "nodePar") <- list(lab.col = as.vector(batch[attr(x, "label")])) 
        ## label by outcome
        attr(x, "label") <- as.vector(labels[attr(x, "label")])
    }
    x
}

plot.batch <- function(dendrogram, batching, se, out){
    # Function to see the batch
    # Given a sampleDendogram use batching to colour the leafs by sample.names of se
    sample.names = colnames(se)
    batch <- as.integer(factor(batching))
    names(batch) <- sample.names
    i.dendrogram <- dendrapply(dendrogram, help.dendogram, batch, out)
    plot(i.dendrogram, main = "Hierarchical clustering")
    legend("topright", paste("Batch", levels(factor(batching))), fill = sort(unique(batch)))
}
```

With this functions to plot the clustering with different labelings is easier:

```{r clustering.n1, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.n1}Figure 13.A: Hierarchical clustering of the samples by portion"}
d <- as.dist(1-cor(assays(thca.filtered)$cqn.logCPM, method = "spearman"))
sampleClustering <- hclust(d)
sampleDendrogram <- as.dendrogram(sampleClustering, hang = 0.1)
outcome <- paste(substr(colnames(thca.filtered), 9, 12),
                        as.character(thca.filtered$type), sep = "-")
names(outcome) <- colnames(thca.filtered)
par(mfrow = c(1,1))
plot.batch(sampleDendrogram, portion, thca.filtered, outcome)
```
```{r clustering.n2, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.n2}Figure 13.B: Hierarchical clustering of the samples by sample vial"}
plot.batch(sampleDendrogram, samplevial, thca.filtered, outcome)
```
```{r clustering.n3, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.n3}Figure 13.C: Hierarchical clustering of the samples by TSS"}
plot.batch(sampleDendrogram, tss, thca.filtered, outcome)
```
```{r clustering.n4, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.n4}Figure 13.D: Hierarchical clustering of the samples by type"}
plot.batch(sampleDendrogram, as.character(thca.filtered$type), thca.filtered, outcome)
```
```{r clustering.n5, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.n1}Figure 13.E: Hierarchical clustering of the samples by prospective collection"}
plot.batch(sampleDendrogram, as.character(thca.filtered$prospective_collection), thca.filtered, outcome)
```
We can see that the sample from A3PR-normal clusters with the tumoral ones, and the A3H2 tumoral clusters with the healthy patients. 
There might be a batch effect on the samplevial, that is the order of portion in a sequence of 100 - 120 mg sample portions. We can also observe that there are two groups of tumoral samples, and one of them clusters with one sample from a healthy person. We can see with a PCA that the tumoral and normal cells don't create two clearly separated groups:

```{r mds, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap = "Figure 14: Multidimensional scaling plot of the samples."}
for (batching in list(portion, as.character(thca.filtered$type), as.character(thca.filtered$gender))){
    batch <- as.integer(factor(batching))
    names(batch) <- sample_names
    plotMDS(dge.subset, labels = outcome, col = batch)
    legend("bottomleft", paste("Batch", levels(factor(batching))),
           fill = sort(unique(batch)), inset = 0.05, cex=0.7)
}
```

We can confirm that there isn't a clear group of normal and tumors and some tumoral samples do mix with the normal ones. And it seems that the females have more variance between healthy and tumoral.

## Removing batch effect

### ComBat

After looking for batch effect we couldn't find a clear cause of the batch effect. We suspect that sample vial has something to do. However, we try to see if we can improve the clustering by using method ComBat for sample vial. 
```{r clustering.combat, message=FALSE, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap = "Figure 15.A: Hierarchical clustering of the samples with ComBat correction."}
library("sva")

# Create the right design matrix
variables.info <- colData(thca.filtered)[, variable.info > 0.6]
treat <- factor(paste(variables.info$type,variables.info$gender,sep="."))
design <- model.matrix(~0+treat)
colnames(design) <- levels(treat)

combatexp <- ComBat(assays(thca.filtered)$cqn.logCPM, tss, mod = design[,-1])

d <- as.dist(1 - cor(combatexp, method = "spearman"))
cluster.combat <- hclust(d)
cluster.combat <- as.dendrogram(cluster.combat, hang = 0.1)
names(batch) <- colnames(thca.filtered)
outcome <- paste(substr(colnames(thca.filtered), 9, 12),
                            as.character(thca.filtered$type), sep = "-")
names(outcome) <- colnames(thca.filtered)

plot.batch(cluster.combat, samplevial, thca.filtered, outcome)
```
```{r clustering.combat2, message=FALSE, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap = "Figure 15.B: Hierarchical clustering of the samples with ComBat correction coloured by gender."}
plot.batch(cluster.combat, thca.filtered$gender, thca.filtered, outcome)
```
```{r clustering.combat3, message=FALSE, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap = "Figure 15.C: Hierarchical clustering of the samples with ComBat coloured by type."}
plot.batch(cluster.combat, thca.filtered$type, thca.filtered, outcome)
```

We can observe a slightly improvement, but still some tumoral samples cluster together with the normal ones. 

### QR Decomposition

To improve the batch effect removal we look if QR decomposition yields better results. In this case, we look for sample vial and TSS batch effects removal. To do so, we have to built the full model which would include gender and type as fixed effects. 

```{r clustering.QRdecomposition.1, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.QRdecomposition.1}Figure 16.A: Hierarchical clustering of the samples with QR descompostion for sample vial"}
library("limma")

qrexp <- removeBatchEffect(assays(thca.filtered)$cqn.logCPM, tss, design = design)
d <- as.dist(1 - cor(qrexp, method = "spearman"))
cluster.qr <- hclust(d)
cluster.qr <- as.dendrogram(cluster.qr, hang = 0.1)

plot.batch(cluster.qr, samplevial, thca.filtered, outcome)
```
```{r clustering.QRdecomposition.2, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.QRdecomposition.2}Figure 16.B: Hierarchical clustering of the samples with QR descompostion for TSS"}
plot.batch(cluster.qr, tss, thca.filtered, outcome)
```
```{r clustering.QRdecomposition.3, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.QRdecomposition.3}Figure 16.C: Hierarchical clustering of the samples with QR descompostion for gender"}
plot.batch(cluster.qr, thca.filtered$gender, thca.filtered, outcome)
```
```{r clustering.QRdecomposition.4, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.QRdecomposition.4}Figure 16.D: Hierarchical clustering of the samples with QR descompostion for type"}
plot.batch(cluster.qr, thca.filtered$type, thca.filtered, outcome)
plot.batch(cluster.qr, tss, thca.filtered, outcome)
```

With QR decomposition we can observe that just one normal sample clusters with tumoral ones,  and we can't observe other factor influencing this clustering.

### Removing batch effect with SVD

We further try if SVD returns a better result:

```{r clustring.svd1, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.svd1}Figure 17.A: Hierarchical clustering of the samples with SVD for sample vial"}
library("corpcor")
s <- fast.svd(t(scale(t(assays(thca.filtered)$cqn.logCPM),
                      center = TRUE, scale = TRUE)))
pcSds <- s$d
pcSds[1] <- 0
svdexp <- s$u %*% diag(pcSds) %*% t(s$v)
colnames(svdexp) <- colnames(thca.filtered)
class(svdexp)
dim(svdexp)

d <- as.dist(1 - cor(svdexp, method = "spearman"))
cluster.svd <- hclust(d)
cluster.svd <- as.dendrogram(cluster.svd, hang = 0.1)
names(batch) <- colnames(thca.filtered)

plot.batch(cluster.svd, samplevial, thca.filtered, outcome)
```
```{r clustring.svd2, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.svd2}Figure 17.B: Hierarchical clustering of the samples with SVD for TSS"}
plot.batch(cluster.svd, tss, thca.filtered, outcome)
```
```{r clustring.svd3, fig.height = 7, fig.width = 14, dpi = 100, echo = TRUE, fig.cap="\\label{fig:clustering.svd3}Figure 17.C: Hierarchical clustering of the samples with SVD for type"}
plot.batch(cluster.svd, thca.filtered$type, thca.filtered, outcome)
```

SVD clusters together normal and tumoral samples, maybe because some of them are quite similar according to the PCA previously performed.
After all the process the best one, that separates better tumor and normal samples is the qr decomposition, which will be used for following-up analysis.

```{r qrexpr}
assays(thca.filtered)$qrexp <- qrexp
```

## Differential expression

We perform a simple examination of expression changes and their associated p-values
using the R/Bioconductor package [sva](http://bioconductor.org/packages/sva).
We build the null model with just the intercept (=1) in order to compare it with the previous full model (including gender and type).

```{r sva.model, cache=TRUE}
variables0 <- colnames(filtered) # All variables available

mod0 <- model.matrix(~ 1 , data = variables.info)
pv <- f.pvalue(assays(thca.filtered)$qrexp, design, mod0)
sum(p.adjust(pv, method = "fdr") < 0.01)
```

There are `r sum(p.adjust(pv, method = "fdr") < 0.01)` genes changing significantly
their expression at FDR < 1%. In Figure 18 below we show the distribution of the
resulting p-values.

```{r pdist, out.width = "500px", fig.cap = "Figure 18.A: Distribution of raw p-values for an F-test on every gene between tumor and normal samples."}
par(mfrow=c(1,1))
hist(pv, main = "Histogram of p-values", las = 1)
```
```{r pdist2, out.width = "500px", fig.cap = "Figure 18.B: Distribution of raw p-values for an F-test on every gene between tumor and normal samples."}
hist(pv, main = "Histogram of p-values", xlim = c(0, 0.1), breaks = 80)
```

Now, let's estimate surrogate variables using the `sva()` function.

```{r sva.variables, cache = TRUE}
sv <- sva(assays(thca.filtered)$qrexp, design, mod0)
sv$n
```

The SVA algorithm has found `r sv$n` surrogate variables. Let's use them to
assess against the extent of differential expression this time adjusting for these
surrogate variables.

```{r svn.ftest, cache = TRUE}
modsv <- cbind(design, sv$sv)
mod0sv <- cbind(mod0, sv$sv)
pvsv <- f.pvalue(assays(thca.filtered)$qrexp, modsv, mod0sv)
sum(p.adjust(pvsv, method = "fdr") < 0.01)
```

We have increased the number of changing genes to `r sum(p.adjust(pvsv, method = "fdr") < 0.01)`.
Figure 19 shows the resulting distribution of p-values.

```{r psvdist, out.width = "500px", fig.cap = "Figure 19.A: Distribution of raw p-values for an F-test on every gene between tumor and normal samples, adjusting for surrogate variables estimated with SVA."}
hist(pvsv, main = "Histogram of p-values adjusting surrogate variables", 
     las = 1)
```
```{r psvdist2, out.width = "500px", fig.cap = "Figure 19.B: Distribution of raw p-values for an F-test on every gene between tumor and normal samples, adjusting for surrogate variables estimated with SVA."}
hist(pvsv, main = "Histogram of p-values adjusting surrogate variables", 
     las = 1, xlim = c(0, 0.1), breaks = 80)
```

After all this first analysis, we can conclude that aproximatelly 4300 genes have different expression levels among tumor and normal samples. 

We remove the surrogate variable:
```{r remove_surrogates}
# Code from https://www.biostars.org/p/121489/#121500
cleanY = function(y, mod, svs) {
    X = cbind(mod, svs)
    Hat = solve(t(X) %*% X) %*% t(X)
    beta = (Hat %*% t(y))
    rm(Hat)
    gc()
    P = ncol(mod)
    return(y - t(as.matrix(X[,-c(1:P)]) %*% beta[-c(1:P),]))
}

e.no_surrogates <- cleanY(assays(thca.filtered)$qrexp, design, sv$sv)
```

## Functional Annotation

We want ensembl annotation, and gene symbol of our probes, and we want also the gene ontologies from all the human genes (will be later used for functional enrichment:

```{r annot, cache = TRUE}
library("org.Hs.eg.db")
annot <- select(org.Hs.eg.db, 
                columns = c("SYMBOL", "ENSEMBL"),
                keys = rownames(thca.filtered),
                keytype = "ENTREZID")
all.Human.GO <- select(org.Hs.eg.db,
                       columns = "GO", 
                       key = keys(org.Hs.eg.db, keytype = "ENTREZID"), 
                       keytype = "ENTREZID")
annot.Entrez.GO <- select(org.Hs.eg.db, 
                columns = c("GO", "SYMBOL"),
                keys = rownames(thca.filtered),
                keytype = "ENTREZID")
```

## Differential expression of paired data

Using the expression values with batch effect removed by qr decomposition we find the top differentially expressed genes:

```{r DE, cache = TRUE}
# Transform the log2 normalized by cqn to counts without the surrogate variables
n_counts <- apply(e.no_surrogates, 1:2, function(x){2^(x)})

# Normalize by mean variance with voom
vo <- voom(n_counts, design, plot = TRUE)
corfit <- duplicateCorrelation(vo, design, block = variables.info$bcr_patient_barcode)
fit <- lmFit(vo, design, block = variables.info$bcr_patient_barcode,
             correlation = corfit$consensus.correlation)
cm <- makeContrasts(
    FemaleDiseaseVsFemaleNormal = tumor.FEMALE-normal.FEMALE,
    MaleDiseaseVsMaleNormal = tumor.MALE-normal.MALE,
    MaleDiseaseVsFemaleDisease = tumor.MALE-tumor.FEMALE,
    MaleNormalVsFemaleNormal = normal.MALE-normal.FEMALE,
    NormalVsDisease = (tumor.MALE+tumor.FEMALE)-(normal.MALE+normal.FEMALE),
    FemaleVsMale = (tumor.FEMALE+normal.FEMALE)-(tumor.MALE+normal.MALE),
    levels = design)
fit2 <- contrasts.fit(fit, cm)
fit2 <- eBayes(fit2)
# Decide the threshold of differentially expressed genes
lfc_threshold <- log2(4)
res <- decideTests(fit2, lfc = lfc_threshold)
summary(res)
```

Based on these we are only interested in four contrast which will be annotated with symbol and ensembl id:

```{r tt, cache = TRUE}
tt_tumor <- topTable(fit2, number = Inf, coef = "NormalVsDisease", p.value = 0.05)
tt_gender <- topTable(fit2, number = Inf, coef = "FemaleVsMale", p.value = 0.05)
tt_females <- topTable(fit2, number = Inf, coef = "FemaleDiseaseVsFemaleNormal", p.value = 0.05)
tt_males <- topTable(fit2, number = Inf, coef = "MaleDiseaseVsMaleNormal", p.value = 0.05)
    
# Annotate with the gene symbol
tt_tumor <- merge(tt_tumor, annot, by.x = 0, by.y = "ENTREZID", 
                  all.x = T, all.y = F)
tt_gender <- merge(tt_gender, annot, by.x = 0, by.y = "ENTREZID", 
                   all.x = T, all.y = F)
head(tt_tumor)
```

Diagnostics plot:

```{r accuracy, cache = TRUE}
pars <- par(mfrow = c(1, 2), mar = c(4, 5, 2, 2))
hist(tt_gender$P.Value, xlab = "Raw P-values", main = "", las = 1)
qqt(fit2$t[, 6], df = fit2$df.prior + fit2$df.residual[6], main = "", pch = ".", cex = 3)
qqline(fit2$t[, 6], lwd = 2, col = "red")
abline(0, 1, lwd = 2)
mtext("Comparing genes between gender", outer = TRUE, cex = 1.5, side = 3, line = -2)

hist(tt_tumor$P.Value, xlab = "Raw P-values", main = "", las = 1)
qqt(fit2$t[, 5], df = fit2$df.prior + fit2$df.residual[5], main = "", pch = ".", cex = 3)
qqline(fit2$t[, 5], lwd = 2, col = "red")
abline(0, 1, lwd = 2)
mtext("Comparing genes between patients and healthy.", outer = TRUE, cex = 1.5, 
      side = 3, line = -2)

hist(tt_females$P.Value, xlab = "Raw P-values", main = "", las = 1)
qqt(fit2$t[, 1], df = fit2$df.prior + fit2$df.residual[1], main = "", pch = ".", cex = 3)
qqline(fit2$t[, 1], lwd = 2, col = "red")
abline(0, 1, lwd = 2)
mtext("Comparing genes between females patients and healthy.", outer = TRUE, cex = 1.5, 
      side = 3, line = -2)

hist(tt_males$P.Value, xlab = "Raw P-values", main = "", las = 1)
qqt(fit2$t[, 2], df = fit2$df.prior + fit2$df.residual[2], main = "", pch = ".", cex = 3)
qqline(fit2$t[, 2], lwd = 2, col = "red")
abline(0, 1, lwd = 2)
mtext("Comparing genes between male patients and healthy.", outer = TRUE, cex = 1.5, 
      side = 3, line = -2)
```

Volcano plot:

```{r volcanoplot}
volcano <- function(data, title){
    ggplot(data, aes(logFC, B, colour = adj.P.Val)) + geom_point() + b + 
        ggtitle(title) + geom_vline(xintercept = c(2, -2) )+ 
        geom_hline(yintercept = 4.6)
}

volcanoplot(fit2, coef = "FemaleVsMale", highlight = 7,
                  fit2$genes$symbol, main = "model Gender", las = 1)
abline(h = 4.6) # 99% of confidence
abline(v = 2)
abline(v = -2)
volcano(tt_gender, "Comparing males vs females")

volcanoplot(fit2, coef = "NormalVsDisease", highlight = 7,
            fit2$genes$symbol, main = "model Disease", las = 1)
abline(h = 4.6) # 99% of confidence
abline(v = 2)
abline(v = -2)
volcano(tt_tumor, "Comparing healthy vs tumoral")

volcanoplot(fit2, coef = "MaleDiseaseVsMaleNormal", highlight = 7,
            fit2$genes$symbol, main = "Comparing males", las = 1)
abline(h = 4.6) # 99% of confidence
abline(v = 2)
abline(v = -2)
volcano(tt_males, "Comparing males: healthy vs tumoral")

volcanoplot(fit2, coef = "FemaleDiseaseVsFemaleNormal", highlight = 7,
            fit2$genes$symbol, main = "Comparing Females", las = 1)
abline(h = 4.6) # 99% of confidence
abline(v = 2)
abline(v = -2)
volcano(tt_females, "Comparing females: healthy vs tumoral")
```

The number of genes which are differentialed expressed

```{r de.number}
de_tumor <- subset(tt_tumor, abs(logFC) >= lfc_threshold & B >= 4.6 )
de_gender <- subset(tt_gender, abs(logFC) >= lfc_threshold & B >= 4.6)
de_males <- subset(tt_males, abs(logFC) >= lfc_threshold & B >= 4.6)
de_females <- subset(tt_females, abs(logFC) >= lfc_threshold & B >= 4.6)

# Number of genes which pass the filter
de_genes <- c(nrow(de_tumor), nrow(de_gender), nrow(de_males), nrow(de_females))
names(de_genes) <- c("Normal vs Disease", "Females vs Males", "Males", "Females")
de_genes
```

As we can see there aren't any gene of the  comparison male vs female that pass the filter.
We can compare if in the different comparisons such genes remain allways up-regulated or down-regulated:

```{r up_down}

up_down <- function(data,  names = NULL){
    # Classify the genes in up or down, names are the names of the genes and 
    # should be on the same order
    dif_genes <- ifelse(data$logFC >0, "up", "down")
    if (is.null(names)){
        names(dif_genes) <- rownames(data)
    } else {
        names(dif_genes) <- names
    }
    
    dif_genes
}

classify <- function(regulated1, regulated2){
    # Check how much up regulated genes in one comparison are down regulated in others

    inter <- intersect(names(regulated1), names(regulated2))
    
    genes <- c()
    genes2 <- c()
    
    # Reorder them by the name for the comparison with table
    for (name in inter){
        genes <- c(genes, regulated1[name])
        genes2 <- c(genes2, regulated2[name])
    }
    
    # Perform the comparison
    table(genes, genes2, 
          dnn = c(deparse(substitute(regulated1)), deparse(substitute(regulated2))))
}

genes_names <- function(regulated1, regulated2){
    # Extract the names of those up-regulated, down-regulated or not clear in
    # both lists
    inter <- intersect(names(regulated1), names(regulated2))
    
    up <- c()
    down <- c()
    not_clear <- c()
    for (name in inter){
        if (regulated1[name] == regulated2[name]){
            if (regulated1[name] == "up"){
                up <- c(up, name)
            } else{
                down <- c(down, name)
            }
        } else{
            not_clear <- c(not_clear, name)
        }
    }
    
    list(up = up, down = down, not_clear =not_clear)
}

r_tumor <- up_down(de_tumor)
r_females <- up_down(de_females)
r_males <- up_down(de_males)

# We collect the name of genes for further studies
genes_females_males <- genes_names(r_females, r_males)
genes_tumor_males <- genes_names(r_tumor, r_males)
genes_tumor_females <- genes_names(r_tumor, r_females)

# We see how do they overlap, more up-regulated, or more dow-regulated genes.
classify(r_tumor, r_males)
classify(r_tumor, r_females)
classify(r_females, r_males)
```

We can observe that all the genes that are up-regulated in one comparison are too up-regulated in other comparisons. Furthermore we can extract the names of the other comparisons to see how much they overlap:

```{r names_overlap}
DE_tumor <- unique(rownames(de_tumor))
DE_males <- unique(rownames(de_males))
DE_females <- unique(rownames(de_females))
```

To visualize it we plot them with venn diagrams:

```{r venn_plots, message=FALSE, warning=FALSE}
library("VennDiagram")
library("Vennerable")

plot(Venn(list(DE_tumor, DE_females),
              SetNames = c("Tumoral", "Females")))

plot(Venn(list(DE_tumor, DE_males),
              SetNames = c("Tumoral", "Males")))

plot(Venn(list(DE_females, DE_males),
              SetNames = c("Females", "Males")))
```

As we can observe of the comparison, many genes differentially expressed on females comparing healthy samples and tumoral ones are not found on males.

##Functional enrichment

We can perform a functional enrichment on our data with the GO already stored

```{r fun.enrich.params_tumors}
library(GOstats)

go_obj <- function(genes_id){
    # Create an object for GOstat from ENTREZIDs
    new("GOHyperGParams", geneIds = genes_id,
                    universeGeneIds = unique(all.Human.GO$ENTREZID),
                    annotation = "org.Hs.eg.db", ontology = "BP",
                    pvalueCutoff = 0.05, testDirection = "over", 
                    conditional = TRUE)
}

params_tumor <- go_obj(DE_tumor)

# The set of differentially expressed only in females
mask <- DE_females %in% intersect(DE_males, DE_females)
DE_females_exc <- DE_females[!mask]
DE_females_exc <- DE_females_exc[!DE_females_exc %in% intersect(DE_females_exc, DE_tumor)]

params_female_exc <- go_obj(DE_females_exc)

# We explore those genes that are shared among the comparisons
go_females_males_up <- go_obj(genes_females_males$up)
go_females_males_down <- go_obj(genes_females_males$down)
go_tumor_males_up <- go_obj(genes_tumor_males$up)
go_tumor_males_down <- go_obj(genes_tumor_males$down)
go_tumor_females_up <- go_obj(genes_tumor_females$up)
go_tumor_females_down <- go_obj(genes_tumor_females$down)
```

Once prepared with the object we can run the analysis:

```{r fun.enrich.tumor_tumors, message=FALSE, cache=TRUE}
go_analisys <- function(go_obj){
    hgOver_tumor <- hyperGTest(go_obj)
    
    GO_tumor <- GOstats::summary(hgOver_tumor)
    
    GO_tumor <- subset(GO_tumor, Size >= 5 & Count >= 5 & Pvalue <= 0.05)
    
    ggplot(GO_tumor, aes(Size, Count, size = OddsRatio, colour = Pvalue)) + 
        geom_point() + b
    
    GO_tumor <- GO_tumor[order(GO_tumor$OddsRatio, decreasing = TRUE), ]
    
    geneIDs <- geneIdsByCategory(hgOver_tumor)[GO_tumor$GOBPID]
    geneSYMs <- sapply(geneIDs, function(id) select(org.Hs.eg.db,
                        columns = "SYMBOL", key = id, keytype = "ENTREZID")$SYMBOL)
    geneSYMs <- sapply(geneSYMs, paste, collapse = ", ")
    GO_tumor <- cbind(GO_tumor, Genes = geneSYMs)
    rownames(GO_tumor) <- 1:nrow(GO_tumor)
    GO_tumor
}

GO_tumor <- go_analisys(params_tumor)
head(GO_tumor)
```

We should do the same if we had some genes differentially expressed on the comparison between gender.

```{r fun.enrich.gender_tumors, echo=TRUE, message=FALSE}
GO_female_exc <- go_analisys(params_female_exc)
head(GO_female_exc)
```


```{r fun.enrich.fmu, echo=TRUE, message=FALSE}
GO_females_males_up <- go_analisys(go_females_males_up)
head(GO_females_males_up)
```

```{r fun.enrich.fmd, echo=TRUE, message=FALSE}
GO_females_males_down <- go_analisys(go_females_males_down)
head(GO_females_males_down)
```

```{r fun.enrich.tmu, echo=TRUE, message=FALSE}
GO_tumor_males_up <- go_analisys(go_tumor_males_up)
head(GO_tumor_males_up)
```


```{r fun.enrich.tmd, echo=TRUE, message=FALSE}
GO_tumor_males_down <- go_analisys(go_tumor_males_down)
head(GO_tumor_males_down)
```

```{r fun.enrich.tfu, echo=TRUE, message=FALSE}
GO_tumor_females_up <- go_analisys(go_tumor_females_up)
head(GO_tumor_females_up)
```

```{r fun.enrich.tfd, echo=TRUE, message=FALSE}
GO_tumor_females_down <- go_analisys(go_tumor_females_down)
head(GO_tumor_females_down)
```

The first thing we can observe is the change of scale in the Odds ratio, now is much more bigger than the previous one.

Looking into the table:

```{r fun.enrich.visualize_tumors}
library(xtable)
xtab_tumor <- xtable(GO_tumor, align="l|c|r|r|r|r|r|p{3cm}|p{3cm}|")
# print(xtab_tumor)
# print(xtab_tumor, file="GO_tumor.html", type="html")
# 
# browseURL("GO_tumor.html")
# 
# xtab_gender <- xtable(hgOver_female_exc, align="l|c|r|r|r|r|r|p{3cm}|p{3cm}|")
# print(xtab_gender, file="hgOver_female_exc.html", type="html")
# 
# browseURL("hgOver_female_exc.html")
```


## SessionInfo

```{r sessionInfo}
sessionInfo()
```


##Bibliography

* Agrawal N, Akbani R, Aksoy BA, Ally A, Arachchi H, Asa SL, Zou L. (2014). Integrated Genomic Characterization of Papillary Thyroid Carcinoma. Cell, 159(3), 676-690. 
* The Canger Genome Atlas. Papillary Thyroid Carcinoma. Retrieved May 6, 2016. Available from: http://cancergenome.nih.gov/cancersselected/thyroid
* Xing M. (2013). Molecular pathogenesis and mechanisms of thyroid cancer. Nature Reviews. Cancer, 13(3), 184-99. 
